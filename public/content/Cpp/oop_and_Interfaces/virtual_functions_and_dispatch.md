# Виртуальные функции и диспетчеризация в C++

## Описание

Этот документ посвящён механизму виртуальных функций, таблицам виртуальных функций (vtable), а также различиям между статической и динамической диспетчеризацией. Эти темы важны при собеседованиях, так как напрямую касаются принципов ООП в C++ и внутренних деталей реализации.

---

## Вопросы и ответы

### ❓ Что такое виртуальная функция?

**Ответ:**  
Это функция-член класса, которая может быть переопределена в производных классах и вызываться по указателю или ссылке на базовый класс, при этом будет вызвана версия из реального типа объекта (динамический полиморфизм).

```cpp
struct Base {
    virtual void foo() { std::cout << "Base\n"; }
};

struct Derived : Base {
    void foo() override { std::cout << "Derived\n"; }
};
```

---

### ❓ Что такое vtable и vptr?

**Ответ:**

- `vtable` (virtual table) — таблица указателей на виртуальные функции класса.
- `vptr` — указатель в объекте на `vtable` соответствующего динамического типа.

При вызове виртуальной функции через базовый указатель:

```cpp
Base* ptr = new Derived();
ptr->foo(); // Через vptr выбирается правильная реализация foo()
```

---

### ❓ Как компилятор реализует вызов виртуальной функции?

**Ответ:**  
На уровне ассемблера это:

1. Загрузка vptr из объекта.
2. По смещению выбирается нужная функция в vtable.
3. Совершается косвенный вызов функции по указателю.

---

### ❓ Чем отличается виртуальный вызов от невиртуального?

**Ответ:**  
- **Невиртуальный** — статическая диспетчеризация. Выбор функции происходит на этапе компиляции.
- **Виртуальный** — динамическая диспетчеризация. Функция выбирается в рантайме через vtable.

---

### ❓ Что будет, если не сделать деструктор базового класса виртуальным?

**Ответ:**  
Удаление производного объекта через указатель на базовый приведёт к **утечке памяти**, так как не будет вызван деструктор производного класса.

```cpp
struct Base {
    ~Base() { std::cout << "Base dtor\n"; }
};

struct Derived : Base {
    ~Derived() { std::cout << "Derived dtor\n"; }
};

Base* ptr = new Derived();
delete ptr; // UB, вызов только ~Base()
```

---

### ❓ Что такое override и final?

**Ответ:**

- `override` — компилятор проверяет, действительно ли вы переопределяете виртуальную функцию.
- `final` — запрет на дальнейшее переопределение этой функции или класса.

---

### ❓ Можно ли сделать виртуальный конструктор?

**Ответ:**  
Нет. Виртуальные функции требуют объект с vptr, а конструктор вызывается до полной инициализации объекта. Но можно использовать **виртуальную фабрику** (например, `clone()`).

---

### ❓ Как работает `dynamic_cast` и почему нужен `vtable`?

**Ответ:**  
`dynamic_cast` использует RTTI и таблицы vtable для проверки фактического типа объекта. Без виртуальных функций (и, соответственно, vtable) `dynamic_cast` не работает.

---

### ❓ Можно ли переопределить виртуальную функцию как `non-virtual`?

**Ответ:**  
Нет. Переопределение виртуальной функции **всегда остаётся виртуальным**, даже если не указать `virtual` в производном классе.

---

## Практика

```cpp
struct A {
    virtual void f() { std::cout << "A\n"; }
};

struct B : A {
    void f() override { std::cout << "B\n"; }
};

void test(A* a) {
    a->f(); // Вызов через vtable
}
```

Вызов `test(new B);` напечатает `B`.

---

## Рекомендации

- Никогда не забывайте делать деструкторы виртуальными в базовых классах с виртуальными методами.
- Используйте `override` для безопасности.
- Изучите поведение vtable на практике с помощью отладчика или вывода ассемблера.

