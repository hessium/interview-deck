# Общие вопросы по C++, которые не попали в другие категории

## Вопросы по анализаторы кода
### 1. Для чего обычно используют ThreadSanitizer?
**ThreadSanitizer (TSan)** — это инструмент статико-динамического анализа, который используется **для обнаружения проблем многопоточности в C/C++** 
(и других языках, например Go). 
Он особенно полезен в сложных многопоточных приложениях, где ошибки могут быть трудноуловимыми и воспроизводятся не всегда.

| Проблема     | Объяснение  |
|----------------------|-------------|
| Data race    | Когда два потока обращаются к одной переменной одновременно, и хотя бы одно из обращений — запись, **без синхронизации.**  |
| Use-after-free (в многопоточной среде)     | Один поток освобождает память, другой — еще использует.   |
| Deadlocks (частично)     | Обнаруживает некоторые взаимные блокировки.  |

### 2. Для чего обычно используют AddressSanitizer?
AddressSanitizer (ASan) поддерживается в clang и gcc, показывает:
- Утечки памяти
- Use-after-free
- Stack/heap overflows

## Вопросы по устройство памяти

### Что такое стек (stack)?
**Стек** — это область памяти, которая используется для:
- хранения локальных переменных,
- аргументов функции,
- адресов возврата,
- контекста выполнения (в том числе регистров и кадров вызова)

**Как происходит выделение памяти на стеке?**
При вызове функции **уменьшается указатель стека (stack pointer)**

На новом участке памяти размещаются:
- параметры функции,
- локальные переменные,
- адрес возврата.

При выходе из функции rsp просто сдвигается назад — и стек "освобождается".

### Что такое стек (stack)?
**Куча** — это динамическая область памяти, из которой **можно выделять и освобождать память вручную**.

- Используется через `malloc/free` в C, `new/delete` в C++, `std::make_shared`, `std::vector` и т.п.
- Управляется через специальный аллокатор, который поддерживает свободные и занятые блоки.

**Как происходит выделение на куче?**

- Вызывается `malloc(size)` или `new Type(...)`
- Аллокатор ищет подходящий блок, помечает его как занятый, и возвращает указатель.
- Освобождение происходит вручную `(free, delete)` или через **RAII** (`std::unique_ptr, std::vector` и т.п.).

## Вопросы по исключениям

### Что будет если выпустить исключение в функции, помеченной noexcept?
Если в функции, объявленной как `noexcept`, будет выброшено исключение, произойдёт **немедленный вызов** `std::terminate()`, и программа аварийно завершится.
```c++
void foo() noexcept {
    throw std::runtime_error("error");  // std::terminate будет вызван
}
```

**Важно**: `noexcept` — это обещание, что функция не выбрасывает исключений. Нарушение этого контракта — фатальная ошибка во время выполнения.

---

## Вопросы по оптимизациям

### Что такое copy elision?

Copy elision (устранение копирования) — это оптимизация, при которой компилятор избегает создания временных объектов. Это снижает накладные расходы.

Когда применяется?
1. Возврат объекта из функции:

```c++
struct A {
    A() { std::cout << "A created\n"; }
    A(const A&) { std::cout << "A copied\n"; }
};

A createA() {
    return A(); // Оптимизировано: нет копирования!
}

int main() {
    A obj = createA(); // Никаких копирований!
}
```

**Без copy elision:**
- Создается временный A внутри createA().
- Копируется в obj.
**С copy elision (RVO - Return Value Optimization):**
- obj создается сразу в месте вызова createA().

**Когда copy elision не срабатывает?**
- Если компилятор не уверен, что может избежать копирования.
```c++
A obj1;
A obj2 = obj1; // Не устраняется (если не `= default`)
```
- Если вручную переопределён конструктор перемещения (A(A&&)) — тогда компилятор его вызовет.
