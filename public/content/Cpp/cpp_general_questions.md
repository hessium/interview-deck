# Общие вопросы по C++, которые не попали в другие категории

## Вопросы по анализаторы кода
### 1. Для чего обычно используют ThreadSanitizer?
**ThreadSanitizer (TSan)** — это инструмент статико-динамического анализа, который используется **для обнаружения проблем многопоточности в C/C++** 
(и других языках, например Go). 
Он особенно полезен в сложных многопоточных приложениях, где ошибки могут быть трудноуловимыми и воспроизводятся не всегда.

| Проблема     | Объяснение  |
|----------------------|-------------|
| Data race    | Когда два потока обращаются к одной переменной одновременно, и хотя бы одно из обращений — запись, **без синхронизации.**  |
| Use-after-free (в многопоточной среде)     | Один поток освобождает память, другой — еще использует.   |
| Deadlocks (частично)     | Обнаруживает некоторые взаимные блокировки.  |

### 2. Для чего обычно используют AddressSanitizer?
AddressSanitizer (ASan) поддерживается в clang и gcc, показывает:
- Утечки памяти
- Use-after-free
- Stack/heap overflows

## Вопросы по устройство памяти

### Что такое стек (stack)?
**Стек** — это область памяти, которая используется для:
- хранения локальных переменных,
- аргументов функции,
- адресов возврата,
- контекста выполнения (в том числе регистров и кадров вызова)

**Как происходит выделение памяти на стеке?**
При вызове функции **уменьшается указатель стека (stack pointer)**

На новом участке памяти размещаются:
- параметры функции,
- локальные переменные,
- адрес возврата.

При выходе из функции rsp просто сдвигается назад — и стек "освобождается".

### Что такое куча (heap)?
**Куча** — это динамическая область памяти, из которой **можно выделять и освобождать память вручную**.

- Используется через `malloc/free` в C, `new/delete` в C++, `std::make_shared`, `std::vector` и т.п.
- Управляется через специальный аллокатор, который поддерживает свободные и занятые блоки.

**Как происходит выделение на куче?**

- Вызывается `malloc(size)` или `new Type(...)`
- Аллокатор ищет подходящий блок, помечает его как занятый, и возвращает указатель.
- Освобождение происходит вручную `(free, delete)` или через **RAII** (`std::unique_ptr, std::vector` и т.п.).

## Вопросы по исключениям

### Что будет если выпустить исключение в функции, помеченной noexcept?
Если в функции, объявленной как `noexcept`, будет выброшено исключение, произойдёт **немедленный вызов** `std::terminate()`, и программа аварийно завершится.
```c++
void foo() noexcept {
    throw std::runtime_error("error");  // std::terminate будет вызван
}
```

**Важно**: `noexcept` — это обещание, что функция не выбрасывает исключений. Нарушение этого контракта — фатальная ошибка во время выполнения.

---

## Кастинг значений

`dynamic_cast` 
- использует RTTI и таблицы vtable для проверки фактического типа объекта. 
- Без виртуальных функций (и, соответственно, vtable) `dynamic_cast` не работает.

### Отличие static_cast и reinterpret_cast

`static_cast<T>(expr)`
- Безопаснее, чем `reinterpret_cast`;
- Проверяет наличие допустимого преобразования во время компиляции;

**Используется для:**
- преобразования между числовыми типами (int → float);
- **восходящего/нисходящего преобразования** в иерархии классов (без виртуального метода);
- преобразования указателей **между связанными типами**;
- вызова **явного конструктора**.
```c++
double d = 3.14;
int i = static_cast<int>(d);  // OK
```

`reinterpret_cast<T>(expr)`
- Низкоуровневое преобразование битов одного типа в другой; 
- Не гарантирует, что результат будет корректным или безопасным;

**Используется для:**
- приведения указателей несвязанных типов;
- работы с raw memory, кастов к `uintptr_t`, `void*`;
- системного программирования и чтения бинарных протоколов.

```c++
int i = 0x3f800000; // битовое представление float 1.0
float f = *reinterpret_cast<float*>(&i);
```

---

## Ключевое слово

### Для чего нужно ключевое слово volatile?

`volatile` говорит компилятору: не оптимизируй доступ к этой переменной, 
т.к. её значение может измениться **вне зависимости от потока управления программы** — например,
изменено другим потоком, сигналом, ISR (interrupt service routine), или из оборудования.
```c++
volatile bool stop = false;

void thread_loop() {
    while (!stop) {
        // do something
    }
}
```
Без `volatile`, компилятор может оптимизировать stop и загрузить его значение один раз — и зациклиться навсегда.
Использование в **обработчиках прерываний и низкоуровневом доступе к памяти или регистрам устройств**, например:

```c++
volatile int* uart_register = reinterpret_cast<volatile int*>(0xDEADBEEF);
*uart_register = 0x01;
```
Если **не указать volatile**, то компилятор может оптимизировать доступ к памяти по адресу `0xDEADBEEF` 
— и поведение программы **станет непредсказуемым или неправильным**.

**Компилятор может:**
- Кэшировать значение переменной в регистре и не читать память повторно;
- Удалить запись вообще, если считает, что она не влияет на состояние программы («мертвый код»).


### Для чего нужно ключевое слово mutable?

`mutable` позволяет **изменять значение поля даже в** `const` **контексте**, то есть когда переменная 
объекта объявлена как `const`, или метод объявлен как `const`.

```c++
class Timer {
    mutable int call_count = 0;

public:
    void log() const {
        ++call_count; // допустимо, потому что поле mutable
    }
};
```
Здесь `log() — const`, но `call_count` всё равно можно изменять.

**Когда это нужно:**
- Кэширование результата внутри const метода; 
- Ведение счётчиков, логгирования, статистики; 
- Любая служебная информация, не влияющая на логическое состояние объекта.

**Использование с лямбда-функциями:**

По умолчанию в C++ **захваченные по значению переменные внутри лямбды нельзя изменять**, 
так как `operator()` у лямбды — `const`.

Здесь `mutable` разрешает изменять копии захваченных переменных внутри тела лямбды. 
Без `mutable` компилятор не даст изменить **x**.

### Ключевое слово explicit

Запрещает **неявное** использование конструктора или оператора преобразования. 
Полезно для избежания **скрытых преобразований**, которые могут приводить к багам.
```c++
struct MyClass {
    explicit MyClass(int x) { }
};

void foo(MyClass obj) {}

foo(10);  // ❌ ошибка: требуется MyClass, не int
foo(MyClass(10));  // ✅ явный вызов
```

---

## Вопросы по строкам

### Что такое UTF-8?

**UTF-8** — это способ закодировать символы (буквы, цифры, знаки и даже смайлики) в **байты**. 
Он относится к семейству **Unicode** — системы, которая даёт каждому символу в мире свой уникальный номер (кодовую точку).

**Особенности UTF-8:**
- Использует от 1 до 4 байт на символ.
- Совместим с ASCII (английский алфавит, цифры и базовые символы занимают 1 байт).
- Поддерживает все языки мира, включая русский, китайский, арабский, эмодзи и др.

**Как это выглядит в C++?**

```c++
std::string s = "Hello";          // ASCII — 1 байт на символ
std::string r = "Привет";         // UTF-8, 2 байта на символ
std::string e = "💖";             // UTF-8, 4 байта на символ
```

**английские символы** — это подмножество **UTF-8**, которое укладывается в **1 байт** (ASCII).

В C++ `std::string` хранит **байты**, а не символы. Поэтому:
- `s.size()` будет 5 (5 букв по 1 байту),
- `r.size()` будет 12 (6 букв по 2 байта),
- `e.size()` будет 4 (1 символ 💖, 4 байта).

Если ты хочешь оперировать **именно символами** (а не байтами), тебе понадобится сторонняя библиотека (например, `utf8cpp`) 
или использовать `std::u32string` (с фиксированным размером 4 байта на символ), но это уже не UTF-8.

---

## Вопросы по оптимизациям

### Что такое copy elision?

Copy elision (устранение копирования) — это оптимизация, при которой компилятор избегает создания временных объектов. Это снижает накладные расходы.

Когда применяется?
1. Возврат объекта из функции:

```c++
struct A {
    A() { std::cout << "A created\n"; }
    A(const A&) { std::cout << "A copied\n"; }
};

A createA() {
    return A(); // Оптимизировано: нет копирования!
}

int main() {
    A obj = createA(); // Никаких копирований!
}
```

**Без copy elision:**
- Создается временный A внутри createA().
- Копируется в obj.
**С copy elision (RVO - Return Value Optimization):**
- obj создается сразу в месте вызова createA().

**Когда copy elision не срабатывает?**
- Если компилятор не уверен, что может избежать копирования.
```c++
A obj1;
A obj2 = obj1; // Не устраняется (если не `= default`)
```
- Если вручную переопределён конструктор перемещения (A(A&&)) — тогда компилятор его вызовет.
