# Гонки данных и мьютексы в C++

## Описание

Этот файл содержит обзор тем, связанных с гонками данных (race conditions), синхронизацией с помощью мьютексов, особенностями std::lock_guard и std::unique_lock, а также потенциальными проблемами, связанными с многопоточным доступом к разделяемым ресурсам.

---

## Вопросы и ответы

### Что такое race condition?

**Ответ:**  
Race condition — это ошибка синхронизации, возникающая при конкурентном доступе нескольких потоков к общему ресурсу, где результат зависит от порядка выполнения операций. Это приводит к неопределённому поведению программы.

**Как в C++ предотвратить гонки данных?**

**Ответ:**  
Обычно используют мьютексы (`std::mutex`, `std::recursive_mutex` и др.), которые синхронизируют доступ к разделяемым ресурсам. Также можно использовать атомарные типы (`std::atomic`) для безопасного доступа к примитивным данным без блокировок.

---

### В чём разница между std::lock_guard и std::unique_lock?

**Ответ:**

| Свойство                | `std::lock_guard`           | `std::unique_lock`              |
|-------------------------|-----------------------------|----------------------------------|
| Простота                | Очень простой, RAII-обёртка | Более гибкий                     |
| Возможность отложить lock | ❌ Нет                      | ✅ Есть через `defer_lock`       |
| unlock вручную          | ❌ Нет                      | ✅ Есть `unlock()`               |
| Перемещение             | ❌ Нет                      | ✅ Есть `std::move()`            |
| Использование с condition_variable | ❌ Нет             | ✅ Необходимо для `.wait()`      |

---

### Что такое deadlock и как его избежать?

**Ответ:**  
Deadlock (взаимная блокировка) возникает, когда два или более потока блокируют ресурсы и ждут друг друга бесконечно. Методы предотвращения:

- Захватывать мьютексы в фиксированном порядке.
- Использовать `std::lock()` для атомарного захвата нескольких мьютексов.
- Использовать `std::scoped_lock` (C++17) для безопасного захвата нескольких мьютексов.

---

### Что делает std::lock?

**Ответ:**  
`std::lock()` — это функция, которая захватывает несколько мьютексов сразу, без риска взаимной блокировки. Все мьютексы блокируются атомарно (внутри алгоритм с защитой от deadlock).

Пример:
```cpp
std::mutex m1, m2;

void foo() {
    std::lock(m1, m2); // безопасно захватывает оба
    std::lock_guard<std::mutex> lg1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> lg2(m2, std::adopt_lock);
}
```

---

### Чем отличается std::adopt_lock?

**Ответ:**  
`std::adopt_lock` говорит `lock_guard` или `unique_lock`, что мьютекс уже заблокирован, и его не нужно блокировать повторно в конструкторе. Полезно после `std::lock()`.


---

### Что такое data race с точки зрения стандарта?

**Ответ:**  
Data race по стандарту C++ — это ситуация, когда два потока одновременно обращаются к одной и той же переменной, и хотя бы одно обращение — на запись, и отсутствует механизм синхронизации. Такое поведение — **undefined behavior**.

---

## Рекомендации

- Используйте RAII-обёртки (`lock_guard`, `unique_lock`).
- Избегайте длительных операций внутри критических секций.
- Используйте атомарные типы, если это возможно и оправдано.

---

## std::atomic и его использование

### Когда стоит использовать std::atomic вместо мьютекса?

**Ответ:**  
Если необходимо синхронизировать доступ к простым типам данных (например, счётчику или флагу), `std::atomic` быстрее и не требует блокировок. Однако для сложных операций с несколькими переменными или взаимодействий лучше подходят мьютексы.

### Spinlock 

Еще один низкоуровневый примитив синхронизации.
Вот простая и современная реализация с использованием `std::atomic_flag`:

```c++
class Spinlock {
    std::atomic_flag flag = ATOMIC_FLAG_INIT;

public:
    void lock() {
        while (flag.test_and_set(std::memory_order_acquire)) {
            // busy-wait (spin) until the lock is released
            std::this_thread::yield(); // optional: yield to reduce CPU pressure
        }
    }

    void unlock() {
        flag.clear(std::memory_order_release);
    }
};
```

Реализация обретка `RAII`:

```c++
class SpinlockGuard {
    Spinlock& spin;
public:
    explicit SpinlockGuard(Spinlock& s) : spin(s) { spin.lock(); }
    ~SpinlockGuard() { spin.unlock(); }
};

// Usage
{
    SpinlockGuard guard(spin);
    // critical section
}

```

**Когда следует использовать spinlock  (в отличие от мьютекса)?**
`spinlock ` не заменяют std::mutex, но могут быть полезны в очень специфических случаях:

**Используйте `spinlock `, когда:**
- Ожидается, что блокировка будет удерживаться в течение очень короткого времени
- Вы работаете в среде реального времени или с низкой задержкой
- Синхронизация с общим ресурсом выполняется в замкнутом цикле (например, запись в небольшой общий буфер)

**Избегайте повторных блокировок, когда:**
- Блокировка может удерживаться более нескольких микросекунд
- Вытеснение потоков является обычным явлением (например, в ОС общего назначения)
- Вызывает беспокойство энергопотребление или загрузка процессора