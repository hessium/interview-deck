# Гонки данных и мьютексы в C++

## Описание

Этот файл содержит обзор тем, связанных с гонками данных (race conditions), синхронизацией с помощью мьютексов, особенностями std::lock_guard и std::unique_lock, а также потенциальными проблемами, связанными с многопоточным доступом к разделяемым ресурсам.

---

## Вопросы и ответы

### ❓ Что такое race condition?

**Ответ:**  
Race condition — это ошибка синхронизации, возникающая при конкурентном доступе нескольких потоков к общему ресурсу, где результат зависит от порядка выполнения операций. Это приводит к неопределённому поведению программы.

---

### ❓ Как в C++ предотвратить гонки данных?

**Ответ:**  
Обычно используют мьютексы (`std::mutex`, `std::recursive_mutex` и др.), которые синхронизируют доступ к разделяемым ресурсам. Также можно использовать атомарные типы (`std::atomic`) для безопасного доступа к примитивным данным без блокировок.

---

### ❓ В чём разница между std::lock_guard и std::unique_lock?

**Ответ:**

| Свойство                | `std::lock_guard`           | `std::unique_lock`              |
|-------------------------|-----------------------------|----------------------------------|
| Простота                | Очень простой, RAII-обёртка | Более гибкий                     |
| Возможность отложить lock | ❌ Нет                      | ✅ Есть через `defer_lock`       |
| unlock вручную          | ❌ Нет                      | ✅ Есть `unlock()`               |
| Перемещение             | ❌ Нет                      | ✅ Есть `std::move()`            |
| Использование с condition_variable | ❌ Нет             | ✅ Необходимо для `.wait()`      |

---

### ❓ Что такое deadlock и как его избежать?

**Ответ:**  
Deadlock (взаимная блокировка) возникает, когда два или более потока блокируют ресурсы и ждут друг друга бесконечно. Методы предотвращения:

- Захватывать мьютексы в фиксированном порядке.
- Использовать `std::lock()` для атомарного захвата нескольких мьютексов.
- Использовать `std::scoped_lock` (C++17) для безопасного захвата нескольких мьютексов.

---

### ❓ Что делает std::lock?

**Ответ:**  
`std::lock()` — это функция, которая захватывает несколько мьютексов сразу, без риска взаимной блокировки. Все мьютексы блокируются атомарно (внутри алгоритм с защитой от deadlock).

Пример:
```cpp
std::mutex m1, m2;

void foo() {
    std::lock(m1, m2); // безопасно захватывает оба
    std::lock_guard<std::mutex> lg1(m1, std::adopt_lock);
    std::lock_guard<std::mutex> lg2(m2, std::adopt_lock);
}
```

---

### ❓ Чем отличается std::adopt_lock?

**Ответ:**  
`std::adopt_lock` говорит `lock_guard` или `unique_lock`, что мьютекс уже заблокирован, и его не нужно блокировать повторно в конструкторе. Полезно после `std::lock()`.

---

### ❓ Когда стоит использовать std::atomic вместо мьютекса?

**Ответ:**  
Если необходимо синхронизировать доступ к простым типам данных (например, счётчику или флагу), `std::atomic` быстрее и не требует блокировок. Однако для сложных операций с несколькими переменными или взаимодействий лучше подходят мьютексы.

---

### ❓ Что такое data race с точки зрения стандарта?

**Ответ:**  
Data race по стандарту C++ — это ситуация, когда два потока одновременно обращаются к одной и той же переменной, и хотя бы одно обращение — на запись, и отсутствует механизм синхронизации. Такое поведение — **undefined behavior**.

---

## Рекомендации

- Используйте RAII-обёртки (`lock_guard`, `unique_lock`).
- Избегайте длительных операций внутри критических секций.
- Используйте атомарные типы, если это возможно и оправдано.

