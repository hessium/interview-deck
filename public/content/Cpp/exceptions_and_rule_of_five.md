# Исключения в конструкторах и Rule of Five

## 1. Исключения в конструкторах

### Общая идея

Если в конструкторе выбрасывается исключение, то:

- объект считается **неполностью сконструированным**;
- деструктор **не вызывается**;
- вызываются деструкторы **уже успешно созданных** членов.

Это важно при управлении ресурсами, чтобы избежать утечек.

---

### Пример

```cpp
class A {
public:
    A() {
        std::cout << "A()" << std::endl;
    }
    ~A() {
        std::cout << "~A()" << std::endl;
    }
};

class B {
public:
    B() {
        std::cout << "B()" << std::endl;
        throw std::runtime_error("fail");
    }
    ~B() {
        std::cout << "~B()" << std::endl;
    }
};

class C {
    A a;
    B b;
public:
    C() {}
};
```

### Вывод:

```
A()
B()
terminate called after throwing an instance of 'std::runtime_error'
```

**Важно:** `~A()` будет вызван, `~B()` — нет, `~C()` — тоже нет.

---

## 2. Частичная инициализация

Если исключение происходит в списке инициализации или теле конструктора, то:

- Успешно инициализированные члены уничтожаются.
- Неинициализированные — нет.
- Это не приводит к утечке, если используешь RAII.

---

## 3. Rule of Five

Если класс управляет ресурсами вручную (например, выделяет память), нужно явно определить:

1. Деструктор
2. Конструктор копирования
3. Оператор копирующего присваивания
4. Конструктор перемещения
5. Оператор перемещающего присваивания

---

### Пример: класс `Car`

```cpp
class Engine {};
class Wheel {};

class Car {
    Engine* engine;
    Wheel* wheel;

public:
    // 1. Конструктор
    Car() : engine(new Engine()), wheel(new Wheel()) {}

    // 2. Деструктор
    ~Car() {
        delete engine;
        delete wheel;
    }

    // 3. Копирующий конструктор
    Car(const Car& other)
        : engine(new Engine(*other.engine)),
          wheel(new Wheel(*other.wheel)) {}

    // 4. Копирующее присваивание
    Car& operator=(const Car& other) {
        if (this != &other) {
            delete engine;
            delete wheel;
            engine = new Engine(*other.engine);
            wheel = new Wheel(*other.wheel);
        }
        return *this;
    }

    // 5. Перемещающий конструктор
    Car(Car&& other) noexcept
        : engine(other.engine), wheel(other.wheel) {
        other.engine = nullptr;
        other.wheel = nullptr;
    }

    // 6. Перемещающее присваивание
    Car& operator=(Car&& other) noexcept {
        if (this != &other) {
            delete engine;
            delete wheel;
            engine = other.engine;
            wheel = other.wheel;
            other.engine = nullptr;
            other.wheel = nullptr;
        }
        return *this;
    }
};
```

---

## 4. Частые ошибки

- Не удалять старые ресурсы перед присваиванием.
- Отсутствие noexcept в перемещающих операциях.
- Не реализован один из пяти методов → UB при копировании/перемещении.
- Использование после перемещения (`use-after-move`).

---

## 5. Вопросы на собеседованиях

### ❓ Что произойдет, если выбросить исключение в теле конструктора?

**Ответ:** Объект не будет создан, вызываются деструкторы только у уже инициализированных членов.

---

### ❓ Почему нужен Rule of Five?

**Ответ:** Чтобы корректно управлять вручную выделенными ресурсами при копировании и перемещении объектов.

---

### ❓ Чем отличается поведение `new` и `make_unique` в случае исключения?

**Ответ:** `make_unique` безопаснее — исключение в конструкторе не приведёт к утечке, так как память управляется RAII.

---

## Заключение

Правильная работа с исключениями и Rule of Five — ключ к написанию надёжного и безопасного кода в C++ при ручном управлении ресурсами.

