# Исключения в конструкторах и Rule of Five

## 1. Исключения в конструкторах

### Общая идея

Если в конструкторе выбрасывается исключение, то:

- объект считается **неполностью сконструированным**;
- деструктор **не вызывается**;
- вызываются деструкторы **уже успешно созданных** членов.

Это важно при управлении ресурсами, чтобы избежать утечек.

---

### Пример

```cpp
class A {
public:
    A() {
        std::cout << "A()" << std::endl;
    }
    ~A() {
        std::cout << "~A()" << std::endl;
    }
};

class B {
public:
    B() {
        std::cout << "B()" << std::endl;
        throw std::runtime_error("fail");
    }
    ~B() {
        std::cout << "~B()" << std::endl;
    }
};

class C {
    A a;
    B b;
public:
    C() {}
};
```

### Вывод:

```
A()
B()
terminate called after throwing an instance of 'std::runtime_error'
```

**Важно:** `~A()` будет вызван, `~B()` — нет, `~C()` — тоже нет.

---

## 2. Частичная инициализация

Если исключение происходит в списке инициализации или теле конструктора, то:

- Успешно инициализированные члены уничтожаются.
- Неинициализированные — нет.
- Это не приводит к утечке, если используешь RAII.

---

## 3. Rule of Five

Если класс управляет ресурсами вручную (например, выделяет память), нужно явно определить:

1. Деструктор
2. Конструктор копирования
3. Оператор копирующего присваивания
4. Конструктор перемещения
5. Оператор перемещающего присваивания

---

### Пример: класс `Car`

```cpp
class Engine {};
class Wheel {};

class Car {
private:
    std::unique_ptr<Wheel> m_wheel;
    std::unique_ptr<Engine> m_engine;

public:
    // 1. Конструктор
        Car(Wheel* wheel, Engine* engien)
        : m_wheel(wheel)
        , m_engine(engien)
    {}

    // 2. Деструктор
    ~Car() {
    // Нам не нужно ничего явно удалять. 
    // Потому что мы используем умные указатели.
    }

    // 3. Копирующий конструктор
    Car(Car& new_car)
    {
        m_wheel = std::make_unique<Wheel>(*new_car.m_wheel);
        m_engine = std::make_unique<Engine>(*new_car.m_engine);
    }

    // 4. Копирующее присваивание
    Car& operator=(const Car& new_car)
    {
        if (this == &new_car)
            return *this;

        m_wheel.reset(new Wheel(*new_car.m_wheel));
        m_engine.reset(new Engine(*new_car.m_engine));

        return *this;
    }

    // 5. Перемещающий конструктор
    Car(Car&& other) noexcept
        : m_wheel(std::move(other.m_wheel))
        , m_engine(std::move(other.m_engine))
    {
    }

    // 6. Перемещающее присваивание
    Car& operator=(Car&& other) noexcept
    {
        if (this == &other)
            return *this;

        m_wheel = std::move(other.m_wheel);
        m_engine = std::move(other.m_engine);

        return *this;
    }
};
```

---

## 4. Частые ошибки

- Не удалять старые ресурсы перед присваиванием.
- Отсутствие noexcept в перемещающих операциях.
- Не реализован один из пяти методов → UB при копировании/перемещении.
- Использование после перемещения (`use-after-move`).

---

## 5. Вопросы на собеседованиях

### ❓ Что произойдет, если выбросить исключение в теле конструктора?

**Ответ:** Объект не будет создан, вызываются деструкторы только у уже инициализированных членов.

---

### ❓ Почему нужен Rule of Five?

**Ответ:** Чтобы корректно управлять вручную выделенными ресурсами при копировании и перемещении объектов.

---

### ❓ Чем отличается поведение `new` и `make_unique` в случае исключения?

**Ответ:** `make_unique` безопаснее — исключение в конструкторе не приведёт к утечке, так как память управляется RAII.

---

## Заключение

Правильная работа с исключениями и Rule of Five — ключ к написанию надёжного и безопасного кода в C++ при ручном управлении ресурсами.

