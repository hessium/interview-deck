# Основные особенности C++11 и C++14

## Описание

C++11 и C++14 внесли значительные улучшения в язык, включая поддержку многопоточности, улучшенные шаблоны, удобства синтаксиса и средства для эффективного управления памятью.

---

## Особенности C++11

### 1. `auto` и выведение типа

Позволяет компилятору автоматически определять тип переменной:

```cpp
auto x = 42;        // int
auto y = 3.14;      // double
```

---

### 2. `nullptr`

Безопасный указатель, заменяющий `NULL`:

```cpp
int* ptr = nullptr;
```

---

### 3. Range-based `for`

Упрощённый способ итерации по контейнерам:

```cpp
for (int x : vec) {
    std::cout << x << "\n";
}
```

---

### 4. Лямбда-функции

Анонимные функции:

```cpp
auto f = [](int a, int b) { return a + b; };
```

---

### 5. `std::unique_ptr` и `std::shared_ptr`

Умные указатели для автоматического управления памятью:

```cpp
std::unique_ptr<MyClass> uptr(new MyClass);
std::shared_ptr<MyClass> sptr = std::make_shared<MyClass>();
```

---

### 6. Конструкторы перемещения и `move`-семантика

Повышают производительность, особенно при передаче временных объектов:

```cpp
std::vector<int> v1 = {1, 2, 3};
std::vector<int> v2 = std::move(v1); // перемещение
```
---

### Для чего нужен std::forward?

`std::forward` используется для переводки аргументов в универсальной ссылке в шаблонных функциях, чтобы правильно передать их в другие функции, сохраняя их категорию значений (lvalue или rvalue). Это особенно важно в контексте перемещения и копирования объектов.

`std::forward<T>` используется, чтобы правильно передать аргумент дальше, сохраняя его категорию. Это важно, потому что если передан rvalue, нужно выполнить перемещение (move), а если lvalue — обычное копирование.

```c++
void print_value(int&& val) {
    std::cout << "rvalue: " << val << std::endl;
}

void print_value(int& val) {
    std::cout << "lvalue: " << val << std::endl;
}

template <typename T>
void forward_value(T&& val) {
    print_value(std::forward<T>(val));  // сохраняем категорию значения (lvalue или rvalue)
}

int main() {
    int a = 10;
    forward_value(a);         // lvalue
    forward_value(20);        // rvalue
}
```

---

### 7. `= delete`, `= default`

Управление генерацией специальных функций:

```cpp
MyClass(const MyClass&) = delete;
MyClass() = default;
```

---

### 8. `constexpr`

Выражения, вычисляемые на этапе компиляции:

```cpp
constexpr int square(int x) { return x * x; }
```

---

### 9. `std::thread`, `std::mutex`, `std::atomic`

Базовая поддержка многопоточности в стандартной библиотеке:

```cpp
std::thread t([](){ std::cout << "thread\n"; });
t.join();
```

---

## Особенности C++14

### 1. Обобщённые лямбда-выражения

Лямбды с `auto` в параметрах:

```cpp
auto f = [](auto a, auto b) { return a + b; };
```

---

### 2. `decltype(auto)`

Используется для выведения типа вместе с ссылками:

```cpp
decltype(auto) get() { return (x); }
```

---

### 3. `std::make_unique`

Аналог `make_shared`, но для `unique_ptr`:

```cpp
auto ptr = std::make_unique<MyClass>();
```

### 3.1 `Как std::move работает с std::unique_ptr`

- `std::unique_ptr` нельзя копировать (у него удалён copy constructor).
- Но его можно переместить — это и делает std::move.
- После перемещения исходный unique_ptr становится nullptr.
```c++
    void copy_ownership(std::unique_ptr<int> ptr); // Ожидает копию (но копировать нельзя)
    
    take_ownership(std::move(my_ptr)); // ✅ Передача через перемещение
    if (my_ptr == nullptr) 
        std::cout << "my_ptr is now nullptr after move\n";
```
---

### 4. Переменные шаблоны

```cpp
template<typename T>
constexpr T pi = T(3.1415926535897932385);

double x = pi<double>;
```

---

## Частые вопросы на собеседованиях

### ❓ Чем `nullptr` лучше `NULL`?

**Ответ:** `nullptr` — тип `std::nullptr_t`, он не приводит к неоднозначностям при перегрузке функций, в отличие от `NULL`, который — просто `0`.

---

### ❓ Как работают `move`-семантика и конструктор перемещения?

**Ответ:** `
std::move` превращает объект в rvalue-ссылку. Это позволяет конструктору перемещения "забрать" ресурсы у временного объекта вместо копирования.
Это сигнал компилятору: "я больше не буду использовать этот объект, можешь переместить его содержимое".

---

### ❓ Что делает `= delete`?

**Ответ:** Запрещает генерацию определённой функции. Полезно для управления копированием, перемещением и другими операциями.

---

## Заключение

C++11 стал огромным шагом в развитии языка, предоставив мощные средства для написания современного, безопасного и эффективного кода. C++14 в основном упростил использование этих средств.

