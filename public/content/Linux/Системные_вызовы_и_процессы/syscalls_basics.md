
# Основы системных вызовов (syscalls) в Linux

## Описание

Системные вызовы — это интерфейс между пользовательским пространством и ядром операционной системы. С их помощью приложения могут выполнять операции, которые требуют привилегий ядра: работа с файлами, управление памятью, создание процессов и потоков и т.д.

## Что такое системный вызов?

Системный вызов (syscall) — это специальная функция, вызываемая приложением для запроса службы у ядра ОС. Примеры включают: `read`, `write`, `open`, `close`, `fork`, `execve`, `wait`, `mmap` и др.

## Как работает syscall?

1. Программа вызывает библиотечную функцию (например, `read()` из glibc).
2. Эта функция вызывает инструкцию `syscall`, которая переключает процессор в привилегированный режим (ring 0).
3. Ядро обрабатывает запрос, выполняет соответствующую операцию.
4. Результат возвращается обратно в пользовательский код `user space`.

## Примеры популярных системных вызовов

- `read(fd, buf, count)` — чтение данных из файла или устройства.
- `write(fd, buf, count)` — запись данных.
- `open(path, flags)` — открытие файла.
- `close(fd)` — закрытие дескриптора.
- `fork()` — создание нового процесса.
- `execve()` — запуск новой программы.
- `wait()` — ожидание завершения дочернего процесса.


- Файлы: open(), read(), write(), close()
- Процессы: fork(), exec(), wait()
- Сеть: socket(), connect()
- Память: mmap(), brk()

## Читаем данные из файла через syscall

```cpp
#include <unistd.h>   // Для syscall, read, write
#include <fcntl.h>    // Для O_RDONLY
#include <sys/syscall.h> // Определения системных вызовов
int main() {
    int fd = syscall(SYS_open, "test.txt", O_RDONLY); // Открываем файл (syscall open)
    if (fd == -1) {
        std::cerr << "Ошибка открытия файла\n";
        return 1;
    }

    char buffer[128];
    ssize_t bytesRead = syscall(SYS_read, fd, buffer, sizeof(buffer) - 1); // Читаем (syscall read)
    
    if (bytesRead > 0) {
        buffer[bytesRead] = '\0';
        std::cout << "Прочитали: " << buffer << std::endl;
    }

    syscall(SYS_close, fd); // Закрываем файл (syscall close)
    return 0;
}
Что здесь происходит?

`SYS_open` — открываем файл test.txt, получаем файловый дескриптор fd.
`SYS_read` — читаем данные из файла в buffer.
`SYS_close` — закрываем файл.
```

## Часто задаваемые вопросы

### Чем отличается syscall от обычной функции?
Обычные функции выполняются полностью в пользовательском пространстве. Syscall переключает выполнение в ядро.

### Какой overhead у системных вызовов?
Syscalls медленнее обычных функций, т.к. требуют переключения контекста между режимами пользователя и ядра.
Поэтому:
```c++
write(1, "a", 1); // не делать миллион вызовов подряд,  
write(1, "aaaa...", N); // лучше один
```
###  Что такое номера системных вызовов?
Каждый `syscall` имеет уникальный номер. 

Например:
- read — 0
- write — 1
- open — 2
- exit — 60

### Где можно посмотреть номер syscall?
Список номеров syscall можно найти в `/usr/include/asm/unistd_64.h` или использовать `strace` для отслеживания вызовов.

## Полезные инструменты

- `strace ./my_app` — отладка и трассировка системных вызовов.
- `man 2 read` — документация на syscall `read`.

